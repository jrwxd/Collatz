<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Collatz 3D Graph</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #060915;
      --card: rgba(255, 255, 255, 0.04);
      --accent: #ff9b6a;
      --accent-2: #6fd1c5;
      --text: #eef2fb;
      --muted: #99a0b5;
      --border: rgba(255, 255, 255, 0.12);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 18% 20%, rgba(255, 155, 106, 0.14), transparent 35%),
                  radial-gradient(circle at 78% 10%, rgba(111, 209, 197, 0.18), transparent 45%),
                  linear-gradient(135deg, #070b1a 0%, #040712 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 26px;
    }

    .shell {
      width: min(1100px, 100%);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
    }

    header { margin-bottom: 14px; }
    h1 { margin: 0; font-size: clamp(26px, 3vw, 34px); letter-spacing: -0.3px; }
    .tagline { margin: 6px 0 0 0; color: var(--muted); font-size: 15px; max-width: 760px; }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
    }

    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 6px; }

    input[type="number"], input[type="range"] {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 10px;
      font-size: 15px;
      outline: none;
      transition: border 0.15s ease, box-shadow 0.15s ease;
    }

    input[type="number"]:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(255, 155, 106, 0.18); }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

    .btn {
      border: none;
      cursor: pointer;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 14px;
      color: #070b1a;
      background: linear-gradient(135deg, var(--accent), #ffc97a);
      box-shadow: 0 10px 24px rgba(255, 155, 106, 0.28);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(0); box-shadow: 0 8px 16px rgba(255, 155, 106, 0.24); }

    .chip {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      cursor: pointer;
      font-size: 13px;
    }

    .status { color: var(--muted); font-size: 13px; }

    .stage {
      width: 100%;
      height: 560px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: radial-gradient(circle at 40% 30%, rgba(255, 155, 106, 0.08), transparent 38%),
                  radial-gradient(circle at 70% 70%, rgba(111, 209, 197, 0.12), transparent 42%),
                  #070b1a;
      overflow: hidden;
    }

    @media (max-width: 640px) {
      body { padding: 16px; }
      .shell { padding: 14px; }
      .stage { height: 420px; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <h1>Collatz 3D Graph</h1>
      <p class="tagline">One sphere per integer, edges for n -> f(n) (3n+1 map). Animate the sweep from 1..N and watch the graph grow.</p>
    </header>

    <div class="controls">
      <div class="panel">
        <label for="maxN">Max N (10-5000)</label>
        <div class="row">
          <input id="maxN" type="number" min="10" max="5000" step="10" value="800" />
          <button id="rebuild" class="btn" type="button">Rebuild graph</button>
        </div>
      </div>
      <div class="panel">
        <label for="delay">Animation delay (ms per edge)</label>
        <input id="delay" type="range" min="5" max="300" value="24" />
        <div class="row" style="justify-content: space-between; margin-top:6px;">
          <span style="color:var(--muted);">Faster</span>
          <span id="delayLabel" style="font-weight:600;">24 ms</span>
          <span style="color:var(--muted);">Slower</span>
        </div>
      </div>
      <div class="panel">
        <label>Playback</label>
        <div class="row" style="gap:8px;">
          <button id="play" class="btn" type="button">Play</button>
          <button id="reset" class="chip" type="button">Reset</button>
          <span id="status" class="status">Ready</span>
        </div>
      </div>
    </div>

    <div id="stage" class="stage" aria-label="Three.js Collatz graph"></div>
  </div>

  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script>
    // Basic DOM refs
    const maxNInput = document.getElementById('maxN');
    const rebuildBtn = document.getElementById('rebuild');
    const delayInput = document.getElementById('delay');
    const delayLabel = document.getElementById('delayLabel');
    const playBtn = document.getElementById('play');
    const resetBtn = document.getElementById('reset');
    const statusEl = document.getElementById('status');
    const stage = document.getElementById('stage');

    // Three.js objects
    let scene, camera, renderer, group;
    let spheres, edgesGeo, edgesMesh;
    let edgeCount = 0;
    let visibleEdges = 0;
    let playing = false;
    let lastTick = 0;
    let builtMaxN = 0;

    // Constants
    const MIN_N = 10;
    const MAX_N = 5000;

    function clampN(n) {
      if (!Number.isFinite(n)) return 800;
      return Math.min(Math.max(Math.round(n), MIN_N), MAX_N);
    }

    function collatzNext(n) {
      return n % 2 === 0 ? n / 2 : 3 * n + 1;
    }

    function positionFor(n) {
      const angle = n * 0.48;
      const radius = 0.22 * Math.sqrt(n);
      const z = Math.log(n + 1) * 0.7;
      return new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, z);
    }

    function initThree() {
      scene = new THREE.Scene();
      scene.background = null;

      camera = new THREE.PerspectiveCamera(60, stage.clientWidth / stage.clientHeight, 0.1, 2000);
      camera.position.set(0, 0, 24);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(stage.clientWidth, stage.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      stage.innerHTML = '';
      stage.appendChild(renderer.domElement);

      group = new THREE.Group();
      scene.add(group);

      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      const dir = new THREE.DirectionalLight(0xffffff, 0.65);
      dir.position.set(3, 7, 9);
      scene.add(ambient, dir);

      animateRender();
    }

    function buildGraph(maxN) {
      const clamped = clampN(maxN);
      builtMaxN = clamped;
      maxNInput.value = clamped;

      if (!scene) initThree();

      // Nodes as instanced spheres
      const sphereGeo = new THREE.SphereGeometry(0.08, 12, 12);
      const sphereMat = new THREE.MeshStandardMaterial({ color: 0x6fd1c5, roughness: 0.35, metalness: 0.05 });
      spheres = new THREE.InstancedMesh(sphereGeo, sphereMat, clamped);
      const dummy = new THREE.Object3D();
      for (let i = 1; i <= clamped; i++) {
        const p = positionFor(i);
        dummy.position.copy(p);
        dummy.updateMatrix();
        spheres.setMatrixAt(i - 1, dummy.matrix);
      }
      if (group.children.includes(spheres)) group.remove(spheres);
      group.add(spheres);

      // Build edges list (only when both endpoints are within 1..clamped)
      const edgePositions = [];
      const edgeColors = [];
      for (let n = 1; n <= clamped; n++) {
        const nxt = collatzNext(n);
        if (nxt <= clamped) {
          const a = positionFor(n);
          const b = positionFor(nxt);
          edgePositions.push(a.x, a.y, a.z, b.x, b.y, b.z);
          const col = n % 2 === 0 ? [0.44, 0.82, 0.78] : [1, 0.56, 0.44];
          edgeColors.push(...col, ...col);
        }
      }

      edgesGeo = new THREE.BufferGeometry();
      edgesGeo.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
      edgesGeo.setAttribute('color', new THREE.Float32BufferAttribute(edgeColors, 3));
      edgeCount = edgePositions.length / 6; // two vertices per edge
      visibleEdges = 0;
      edgesGeo.setDrawRange(0, 0);

      if (edgesMesh) group.remove(edgesMesh);
      edgesMesh = new THREE.LineSegments(
        edgesGeo,
        new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.9 })
      );
      group.add(edgesMesh);

      statusEl.textContent = `Ready with N=${clamped}, edges=${edgeCount}`;
      playing = false;
      playBtn.textContent = 'Play';
      lastTick = 0;
    }

    function animateEdges(ts) {
      if (!playing || !edgesGeo) return;
      if (!lastTick) lastTick = ts;
      const delay = parseInt(delayInput.value, 10);
      if (ts - lastTick >= delay) {
        visibleEdges = Math.min(visibleEdges + 1, edgeCount);
        edgesGeo.setDrawRange(0, visibleEdges * 2);
        statusEl.textContent = `Drawing edge ${visibleEdges}/${edgeCount}`;
        lastTick = ts;
        if (visibleEdges >= edgeCount) {
          playing = false;
          playBtn.textContent = 'Play';
          statusEl.textContent = `Done (N=${builtMaxN}, edges=${edgeCount})`;
        }
      }
      requestAnimationFrame(animateEdges);
    }

    function animateRender() {
      function loop() {
        if (group) group.rotation.y += 0.0018;
        if (renderer && scene && camera) renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    }

    function handleResize() {
      if (!renderer || !camera) return;
      const { clientWidth, clientHeight } = stage;
      camera.aspect = clientWidth / Math.max(clientHeight, 1);
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
    }

    // Event wiring
    rebuildBtn.addEventListener('click', () => {
      buildGraph(parseInt(maxNInput.value, 10));
    });

    delayInput.addEventListener('input', () => {
      delayLabel.textContent = `${delayInput.value} ms`;
    });

    playBtn.addEventListener('click', () => {
      if (!edgesGeo) return;
      playing = !playing;
      playBtn.textContent = playing ? 'Pause' : 'Play';
      if (playing) {
        lastTick = 0;
        if (visibleEdges >= edgeCount) {
          visibleEdges = 0;
          edgesGeo.setDrawRange(0, 0);
        }
        statusEl.textContent = 'Animating...';
        requestAnimationFrame(animateEdges);
      } else {
        statusEl.textContent = `Paused at edge ${visibleEdges}/${edgeCount}`;
      }
    });

    resetBtn.addEventListener('click', () => {
      visibleEdges = 0;
      if (edgesGeo) edgesGeo.setDrawRange(0, 0);
      playing = false;
      playBtn.textContent = 'Play';
      statusEl.textContent = 'Reset';
    });

    window.addEventListener('resize', handleResize);

    // Initial boot
    buildGraph(parseInt(maxNInput.value, 10));
    handleResize();
  </script>
</body>
</html>
